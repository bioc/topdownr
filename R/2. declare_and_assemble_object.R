
Sys.setenv(LANGUAGE="en")
library (cleaver)
library (OrgMassSpecR)
library (XML)
library (caTools)
library (MSnbase)
library (dplyr)
library (plyr)
library (ggplot2)
library (plyr)
library(gplots)


##################################################################################################################
#0 declare object
##### ####

setClass("protFragOpt", slots =  c("protName", "protSeq", "fragConditions", "predFragTable", "deconvSpectra", "matchedFragmentsTable", "ppmErrorTable", "expResultAggregate", "fragTypeAggregate"))

setMethod("[",
          signature=c("protFragOpt"),
          definition=function(x, i, j, ...,drop) {
            x@fragConditions <- x@fragConditions[i, ];x@fragConditions$MSNOrder <- 1:nrow(x@fragConditions); x@deconvSpectra <- x@deconvSpectra[i];  x@matchedFragmentsTable <- x@matchedFragmentsTable[i]; x@ppmErrorTable <- x@ppmErrorTable[i]; x@fragTypeAggregate <- x@fragTypeAggregate[,i] 
            return (x)
          })

setMethod("length",
          signature=c("protFragOpt"),
          definition=function(x) {
            length (x@deconvSpectra)
          })


##################################################################################################################
#1 make fragmentation table
##### ####
# this function generates fragments for a given protein

C12 <- 12
H   <- 1.0078250321
O   <- 15.9949146221
N   <- 14.0030740052
c13 <- 13.003355

makePredFragTable <- function (protSeqFile, addMZ = NULL, IAA = TRUE, fragTypes = c("a", "b", "c", "cmH", "zpH", "x", "y", "z")){
  
  protSeq <- readLines (protSeqFile)
  predFragTable <- matrix (NA, nrow = (nchar (protSeq) - 1), 
                           ncol = 8,
                           dimnames = list (paste0 ("bond_", 1:(nchar (protSeq) - 1)), c("a", "b", "c", "cmH", "zpH", "x", "y", "z")))
  
  # see the graphical formula for mass difference in the folder
  
  CtoA <- N + H * 3 + C12 + O 
  CtoB <- N + H * 3
  
  buffer <- FragmentPeptide (sequence = protSeq, fragments = "cz", IAA = IAA)
  buffer <- buffer[grep ("1\\+", buffer$ms2type), ]
  
  predFragTable[, "c"] <- buffer[1:(nrow (buffer)/2), "ms2mz"]
  predFragTable[, "z"] <- buffer[(nrow (buffer)/2 + 1):nrow (buffer), "ms2mz"]
  
  predFragTable[, "cmH"] <-  predFragTable[, "c"]  - H 
  predFragTable[, "zpH"] <-  predFragTable[, "z"] + H 
  
  predFragTable[, "b"] <- predFragTable[, "c"] - CtoB
  predFragTable[, "y"] <- predFragTable[, "z"] + CtoB
  
  predFragTable[, "a"] <- predFragTable[, "c"] - CtoA
  predFragTable[, "x"] <- predFragTable[, "z"] + CtoA
  
  predFragTable <- predFragTable[, colnames (predFragTable) %in% fragTypes]
  
  if (!is.null (addMZ)){
    for (i in 1:length (addMZ)){
      buffer <- predFragTable
      buffer <- predFragTable[, fragTypes] + addMZ[[i]]
      colnames (buffer) <- paste (fragTypes, names (addMZ)[i], sep = "_")
      predFragTable <- cbind (predFragTable, buffer)
    }
  } 
  
  colnames (predFragTable) <- paste0 ("pred_",  colnames (predFragTable))
  
  return (predFragTable)
}

########################## ####
# 2) combine mehtod, scanheader Tables and mzMLSpectra
##### #####

# declaration of class ("Protein Fragmentation Optimisation")
# it has the following slots:
# 1) protein name
# 2) sequence
# 3) fragmentation condition is a table with all the fragmentation information: merged from method and scanHeader tables extracted from the raw file
# 4) predFragTable generated by table above
# 5) deconvoluted spectra: produced by Xtract and are XML format
# 6) list of tables with matched Fragments intensities. 
# 7) list of tables with matched Fragments ppm.
# 8) table with aggreagted results

# 6, 7, 8 will be created during analysis




keepCol <- function (colValue) {
  colValue <- colValue[!is.na (colValue)]
  colValue <- colValue[colValue != ""]
  length (unique (colValue)) > 1
}

extractFragmentCondNumber <- function (filterString){
  isolatedMZ <- strsplit (strsplit (filterString, "@")[[1]][1], "ms2 ")[[1]][2]
  condNumber <- as.integer (substr(isolatedMZ, nchar(isolatedMZ)-2, nchar(isolatedMZ)))
  return (condNumber)
}

mergeMethAndSHTables <- function (methodFile, scanHeadsManFile){
  
  methodTable <- read.csv (methodFile, stringsAsFactors = FALSE)
  methodTable <- methodTable[methodTable$MSLevel == 2, ]
  methodTable[is.na (methodTable)] <- 0 
  methodTable["conditionRun"] <- 1:nrow (methodTable) # condition run is used to merge method and ScanHeadsMan tables
  methodTable["selMZ"] <- substr(methodTable$TargetedMassList, 5, 9)
   
  # scan heads table
  scanHeadsTable <- read.csv (scanHeadsManFile, stringsAsFactors = F)
  scanHeadsTable <- scanHeadsTable[scanHeadsTable$MSOrder == 2, ]

  scanHeadsTable["acquisition_name"] <- gsub(".txt", "", scanHeadsManFile)
  
  selETD <- scanHeadsTable$Activation1 == "ETD"
  scanHeadsTable[selETD, "ETD_Activation"] <- scanHeadsTable[selETD, "Energy1"] 
  
  selCID <- scanHeadsTable$Activation1 == "CID"
  scanHeadsTable[selCID, "CID_Activation"] <- scanHeadsTable[selCID, "Energy1"] 
  selCID <- which (scanHeadsTable$Activation2 == "CID")
  scanHeadsTable[selCID, "CID_Activation"] <- scanHeadsTable[selCID, "Energy2"] 
  
  selHCD <- scanHeadsTable$Activation1 == "HCD"
  scanHeadsTable[selHCD , "HCD_Activation"] <- scanHeadsTable[selHCD, "Energy1"] 
  selHCD <- which (scanHeadsTable$Activation2 == "HCD")
  scanHeadsTable[selHCD, "HCD_Activation"] <- scanHeadsTable[selHCD, "Energy2"]
  
  scanHeadsTable [is.na (scanHeadsTable )] <- 0  
  scanHeadsTable ["conditionRun"] <- sapply (scanHeadsTable$FilterString, extractFragmentCondNumber)  
  
  methSHTable <- merge (scanHeadsTable, methodTable, by = "conditionRun", all.y =TRUE)
  methSHTable  <- ddply ( methSHTable ,  .(selMZ, AGCTarget), transform, InjTimeRatioToMedianForMzLog2 = log2(Ion.Injection.Time..ms./median(Ion.Injection.Time..ms.)))
  methSHTable["CID_ETD_HCD_summary"] <- apply (methSHTable[c("CID_Activation", "ETD_Activation", "HCD_Activation")], 1, function (x) paste(x, collapse = "_"))
  
  return (methSHTable)
}

assignFragCond <- function (methSHTable, fragParam){
  parTable    <- methSHTable[, fragParam]
  parTable    <- parTable[!duplicated(parTable), ]
  parTable["condition"]    <- 1:nrow (parTable)
  methSHTable  <- merge (methSHTable, parTable, all = TRUE)
  return (methSHTable)
}


assembleObject <- function (methodFiles, scanHeadsManFiles, mzMLFiles, protSeqFile, predFragTable, fragParam){
  
  methSHTableList <- sapply (gsub ("txt", "", scanHeadsManFiles), function (x) NULL)
  for (i in 1:length (methSHTableList)) methSHTableList[[i]] <- mergeMethAndSHTables(methodFiles[i],  scanHeadsManFiles[i])
  methSHTable <- do.call (rbind, methSHTableList)
  methSHTable <- methSHTable[, apply (methSHTable, 2, keepCol)]
  methSHTable <- assignFragCond(methSHTable, fragParam)
  
  message (paste ("data contains", length (unique (methSHTable$condition)), "fragmentation conditions"))
  
  ggplot(methSHTable, aes(x=AGCTarget, y=Ion.Injection.Time..ms., group= AGCTarget)) + 
    geom_boxplot() + facet_grid ( ~selMZ)
  ggsave(filename="injTime_initial.pdf", width = 12, height = 6)
  
  message ("reading in the MS2 data")
  spectraList     <- readMSData2(mzMLFiles, msLevel. = 2)
  
  spectraTable    <- data.frame (acquisition_name = acquisition_name[fromFile (spectraList)], 
                                 Scan = acquisitionNum (spectraList))
  
  mergedTable <- merge (spectraTable,  methSHTable, sort = FALSE)
  mergedTable["MSNOrder"] <- 1:nrow(mergedTable)
  
  protFragOpt <- new ("protFragOpt", 
                      protName = "h2a",
                      protSeq = protSeq, 
                      predFragTable = predFragTable,
                      fragConditions = mergedTable, 
                      deconvSpectra = spectraList,
                      matchedFragmentsTable =  vector("list", length (spectraList)) , 
                      ppmErrorTable = vector("list", length (spectraList)))

  protFragOpt@fragConditions <- arrange (ddply (protFragOpt@fragConditions, "condition", transform, injTimeRank = rank (abs(InjTimeRatioToMedianForMzLog2))), MSNOrder)
  return (protFragOpt)
}
